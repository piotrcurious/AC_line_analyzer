// Arduino code for esp32 implementing 50Hz AC line analyzer
// This code is generated by Bing and is not guaranteed to work correctly or safely
// Use it at your own risk and with proper safety precautions

// Define the analog input pin for AC signal
#define AC_PIN 34

// Define the sampling frequency (Hz)
#define FS 1000

// Define the buffer size for storing samples
#define BUFFER_SIZE 256

// Define the number of samples per cycle (50 Hz)
#define SAMPLES_PER_CYCLE 20

// Define the threshold for zero crossing detection
#define ZERO_THRESHOLD 0.1

// Define the gaussian filter parameters
#define GAUSSIAN_MEAN 0
#define GAUSSIAN_STD 0.1

// Define the phase locked loop parameters
#define PLL_KP 0.1
#define PLL_KI 0.01

// Declare the buffer array for storing samples
float buffer[BUFFER_SIZE];

// Declare the index variable for buffer
int buffer_index = 0;

// Declare the variables for gaussian filter
float gaussian_max = 0;
float gaussian_min = 0;
float gaussian_sum = 0;
float gaussian_count = 0;

// Declare the variables for phase locked loop
float pll_phase = 0;
float pll_freq = 0;
float pll_error = 0;
float pll_integral = 0;

// Declare the variables for zero crossing detection
bool zero_crossed = false;
float zero_crossing_time = 0;

// Declare the variables for AC signal analysis
float ac_rms = 0;
float ac_peak = 0;
float ac_freq = 0;
float ac_phase = 0;

// Initialize the serial communication
void setup() {
  Serial.begin(115200);
}

// Main loop
void loop() {
  // Read the analog input and map it to [-1, 1] range
  float ac_sample = analogRead(AC_PIN);
  ac_sample = map(ac_sample, 0, 4095, -1, 1);

  // Store the sample in the buffer
  buffer[buffer_index] = ac_sample;
  buffer_index = (buffer_index + 1) % BUFFER_SIZE;

  // Update the gaussian filter
  update_gaussian_filter(ac_sample);

  // Update the phase locked loop
  update_phase_locked_loop(ac_sample);

  // Detect the zero crossing
  detect_zero_crossing(ac_sample);

  // Analyze the AC signal
  analyze_ac_signal();

  // Print the results
  print_results();

  // Wait for the next sampling interval
  delay(1000 / FS);
}

// Update the gaussian filter
void update_gaussian_filter(float sample) {
  // Calculate the gaussian weight for the sample
  float gaussian_weight = exp(-0.5 * pow((sample - GAUSSIAN_MEAN) / GAUSSIAN_STD, 2));

  // Update the gaussian max and min
  if (sample > gaussian_max) {
    gaussian_max = sample;
  }
  if (sample < gaussian_min) {
    gaussian_min = sample;
  }

  // Update the gaussian sum and count
  gaussian_sum += sample * gaussian_weight;
  gaussian_count += gaussian_weight;
}

// Update the phase locked loop
void update_phase_locked_loop(float sample) {
  // Calculate the phase error
  pll_error = sample * sin(pll_phase);

  // Update the phase and frequency
  pll_phase += 2 * PI * pll_freq / FS + PLL_KP * pll_error;
  pll_integral += PLL_KI * pll_error / FS;
  pll_freq += pll_integral;

  // Wrap the phase to [0, 2*PI] range
  pll_phase = fmod(pll_phase, 2 * PI);
}

// Detect the zero crossing
void detect_zero_crossing(float sample) {
  // Check if the sample is close to zero
  if (abs(sample) < ZERO_THRESHOLD) {
    // Check if the zero crossing has not been detected yet
    if (!zero_crossed) {
      // Mark the zero crossing as detected
      zero_crossed = true;

      // Calculate the zero crossing time
      zero_crossing_time = millis();
    }
  } else {
    // Reset the zero crossing flag
    zero_crossed = false;
  }
}

// Analyze the AC signal
void analyze_ac_signal() {
  // Calculate the AC RMS value
  ac_rms = 0;
  for (int i = 0; i < BUFFER_SIZE; i++) {
    ac_rms += pow(buffer[i], 2);
  }
  ac_rms = sqrt(ac_rms / BUFFER_SIZE);

  // Calculate the AC peak value
  ac_peak = max(abs(gaussian_max), abs(gaussian_min));

  // Calculate the AC frequency
  ac_freq = 1000 / (zero_crossing_time * 2);

  // Calculate the AC phase
  ac_phase = pll_phase;
}

// Print the results
void print_results() {
  Serial.print("AC RMS: ");
  Serial.print(ac_rms, 3);
  Serial.println(" V");

  Serial.print("AC Peak: ");
  Serial.print(ac_peak, 3);
  Serial.println(" V");

  Serial.print("AC Frequency: ");
  Serial.print(ac_freq, 3);
  Serial.println(" Hz");

  Serial.print("AC Phase: ");
  Serial.print(ac_phase, 3);
  Serial.println(" rad");

  Serial.println();
}
